use std::io::BufRead;

fn main() {
    let flags = flags::Rumbac::from_env_or_exit();

    use flags::RumbacCmd::*;
    match flags.subcommand {
        List(_) => {
            let ports = serialport::available_ports().expect("Failed to read serial ports");
            println!("Found {} serial ports.", ports.len());
            for p in ports {
                println!("port: {p:?}");
            }
        }
        Info(flags::Info { port }) => {
            // TODO: what baudrate to use by default??
            let bauds = 921600u32;
            use core::time::Duration;
            let mut port = serialport::new(port, bauds)
                .timeout(Duration::from_secs(1))
                .open()
                .expect("Failed to open port");
            let _ = port.write(b"V#").expect("Failed to write to port");
            let mut r = std::io::BufReader::new(port);
            let mut line = String::new();
            let _ = r.read_line(&mut line).expect("Failed to read from port");
            println!("{}", line);
        }
    }
}

mod flags {
    xflags::xflags! {
        src "./src/main.rs"

        cmd rumbac {
            default cmd list { }
            cmd info {
                required -p,--port port: String
            }
        }
    }
    // generated start
    // The following code is generated by `xflags` macro.
    // Run `env UPDATE_XFLAGS=1 cargo build` to regenerate.
    #[derive(Debug)]
    pub struct Rumbac {
        pub subcommand: RumbacCmd,
    }

    #[derive(Debug)]
    pub enum RumbacCmd {
        List(List),
        Info(Info),
    }

    #[derive(Debug)]
    pub struct List;

    #[derive(Debug)]
    pub struct Info {
        pub port: String,
    }

    impl Rumbac {
        #[allow(dead_code)]
        pub fn from_env_or_exit() -> Self {
            Self::from_env_or_exit_()
        }

        #[allow(dead_code)]
        pub fn from_env() -> xflags::Result<Self> {
            Self::from_env_()
        }

        #[allow(dead_code)]
        pub fn from_vec(args: Vec<std::ffi::OsString>) -> xflags::Result<Self> {
            Self::from_vec_(args)
        }
    }
    // generated end
}
